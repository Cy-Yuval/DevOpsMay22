# TODO very good
# Git Basics (commit, diff, branches)

1. echo "1" > abc.txt

2. RED

3. 'git add abc.txt'; GREEN
('git add' - add changes of tracked file to index, that make the file staged)

4. 'echo "2" >> abc.txt'

5. Is the color of abc.txt different from the observed color in step 2?
Yes.
What are the differences between the two outputs of git status command?
Q #2 - the file is untracked. Q #5 - the file is tracked, but changes are not staged.

6. Command to show changes between the working tree to branch main:
'git diff main' - eq last commit;
('git diff HEAD' - eq last commit of the current branch)

7. Why does 'git diff --staged' print nothing?
Because
('git diff --staged' == 'git diff --cached')

8. Why does 'git diff stage2' prints fatal error?
There is no such branch.
What is the error?
The error: "ambiguous argument 'stage2': unknown revision or path not in the working tree."

9. Add abc.txt to the index.
'git add abc.txt'

10. What does 'git diff print'? why?
git diff print nothing, because all the changes are staged.

11. What is the command to show changes between the index and branch main?
'git diff-index main'
('git diff --staged main'; git add -u staging of the changes tracked files)

11. Adding abc.txt to the index:
'git diff --staged' (staged == indexed)

12. Append the line 3 to the end of abc.txt
echo "3" >> abc.txt

13. Would 'git diff --staged' and 'git diff main' commands print the same output?
No.
Why?
'git diff --staged' - shows staged changes (ready for commit after git add command).
'git diff main' - shows difference between main and working tree.

14. Why does abc.txt appear twice in the output of 'git status'?
It shows changes to be committed and changes not staged for commit.

15. Unstage the changes in your index and working tree
'git reset' (older command)
'git restore --staged <filePath>'' (newer command)
'git reset HEAD -- <filePath>' (unstages any modifications made to the file since the last commit (but doesn't revert them in the filesystem); it replaces the index version of the file with the one from repo (HEAD), effectively unstaging the modifications to it.)
'git rm --cached <filePath>' (makes git stop tracking/remove a file from the index (leaving it in the working directory), and a commit will now remove it from the repo as well).

# TODO good
# Resolve conflicts

1. List all existed branches of this repo (print them).
'git branch'

2. Create a new branch called feature/lambda_migration and switch (checkout) to this branch.
'git checkout -b feature/lambda_migration'

3. Merge branch feature/version1 into feature/lambda_migration, observe the merged changes.
'git merge feature/version1' (merge the branch to the current branch)
The changes:
Merge made by the 'ort' strategy.
 .env        | 0
 app.py      | 4 ++--
 config.json | 0
 3 files changed, 2 insertions(+), 2 deletions(-)

4. Using PyCharm UI - merge branch 'feature/version2' into 'feature/lambda_migration'.
Merge 'selected into current' gives an error:
Merging is not possible because you have unmerged files.
hint: Fix them up in the work tree, and then use 'git add/rm '
hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict.

5.
   1. Merge with conflict tool.
   2. Merge all changes - click All.
   3. Annotate with Git Blame.
   4. Accept John Doe's port number (8081), deny Narayan's port (8082)
   5. Accept the function name of Narayan Nadella (get_profile_picture), Block John's name.
6. Are there any added commits for feature/lambda_migration? what are those commits?
There were 2 types of commits: from merged branches, and merge commits.
(git show 88f3692 - details of commit)

# TODO good
# Cherry picking

1. Create a clean fresh branch feature/lambda_migration2, versioned from main.
'git checkout -b feature/lambda_migration2 main'
2. In Pycharm Git tab (bottom left), navigate to tab Log,
filter Branch so only commit of feature/lambda_migration would be shown.
3. In PyCharm UI, use the cherry-pick icon to pick those commits in the following order:
    1. "use correct lock type in reconnect()"
    2. "Restrict the extensions that can be disabled"
4. Which files have been added?
Two files: config.json, .env
(git diff --name-only --diff-filter=A HEAD~2
git log --name-only --oneline -2)

5. Should you care about the order in which commits are picked?
Yes.
Why?
The last commit wins.


# Changes in working tree and switch branches

1. Make sure you are in branch different from dev
(you should be in feature/lambda_migration2 if you follow the exercise in the order it's written).
'cat > take.txt << EOF'

2. Create a new file called take.txt,
write some lines in it and add it to the index (don't commit, only add).
Now you have uncommitted changes in the working tree.

3. Checkout to dev, which error do you get?
error: Your local changes to the following files would be overwritten by checkout:
What are the two approaches suggested by git?
'git stash' or 'git shelve'

4. Using PyCharm UI try to checkout dev again. On the prompted dialog click Force Checkout.

5. Does take.txt contain your changes when you're now in dev?
No.

6. Checkout back to the branch you've come from.
'git checkout -'
Do you have your take.txt there?
There is no 'take.txt'.
So what does Force Checkout do?
Moves files to shelves.  # TODO actually is discards the changes. Moving changes "to the shelve" may be achieved by `git stash`
(ctrl-shift-L - search by menus)

# TODO good
# Reset

1. Checkout reset_question branch.
'git checkout reset_question'

2. Run the following commands line by line,
after each command, observe what happened to your working tree and explain why.
   1. git reset --soft HEAD~1 - reverse last commit, but left the file staged
   2. git reset --mixed HEAD~1 - untrack/unstage 2 files (logically)
   3. git reset --hard HEAD~1 - can remove file or changes (physically)
   4. git revert HEAD~1 - new commit that reverts commit which is the one before HEAD

3. Explain the notation HEAD~1 in git reset command.
Commit which is the one before HEAD

# TODO good
# Working with GitHub

1. In your GitHub account, create a new repository.
2. Add this repo as a remote (origin) to the local repo you've worked on along this exercise.
'git remote add origin https://github.com/vladislav-spector/test_repo.git'
(git remote -v)
3. Push branches main and dev.
'git push origin main'
'git push origin dev'

4. Copy and paste the link to your GitHub repo in the README answers file.
https://github.com/vladislav-spector/test_repo
